// Archivo: Implementación del problema productor-consumidor con monitores
// Autores: Sion-Jei Mamani Leon / Javier Gálvez Gonzalez / Facundo Alexandre Buchelli
// Fecha: 28-12-2020

#include <cstdlib>
#include <vector>
using namespace std;

void main() {
    int numeroDeConsumidores;

    cout << "Ingrese número de consumidores: ";
    cin >> numeroDeConsumidores;
    
    vector<int> buffer;

    // TODO: Validar que el tamaño introducido sea menor a la memoria disponible del computador

    void insertarProducto() {
        /*
            Aquí puede ir cualquier operación para generar un producto
            Por simplicidad, simplemente se introduce un entero aleatorio al buffer.
        */
        buffer.push_back(rand());

        cout << "Estado del buffer: " << buffer << endl;
        for (const auto& i: buffer) {
           cout << i << ' ';
        }
    }

    void retirarProducto() {
        int indiceFinal = buffer.end();
        
        count << "Consumido: " << buffer.at(indiceFinal) << endl;
        /* 
            Aquí puede realizarse cualquier operación
            sobre el producto retirado. Por simplicidad,
            simplemente se desplegará en consola el elemento retirado
        */
        buffer.erase(indiceFinal);
        
        cout << "Estado del buffer: " << buffer << endl;
        for (const auto& producto: buffer) {
           cout << producto << ' ';
        }
    }

    monitor ProductorConsumidor {
        condition bufferVacio, bufferLleno;
        int contador;
        
        procedure productor(){
            if (contador == tamañoBuffer) {
                cout << "Buffer lleno, productor bloqueado." << endl;
                waitc(bufferLleno); // Buffer se encuentra lleno, bloquear proceso
            }
            
            insertarProducto();

            contador++;

            if (contador == 1) {
               signalc(bufferVacio); // Si el buffer estaba vacío, despertar al consumidor
            }
        }

        procedure consumidor() {
            if (contador == 0) {
                count << "Buffer vacío, consumidor bloqueado." << endl;
                waitc(bufferVacio); // buffer está vacio, bloquear proceso
            }

            retirarProducto();
            contador--;

            if (contador == tamañoBuffer - 1) {
                signalc(bufferLleno); // Si el buffer estaba lleno, despertar al productor
            }
        }
    }

    // Inicialización, 1 productor, multiples consumidores
    productor();
    for (int i = 0; i < numeroDeConsumidores; i++) {
        cobegin {
            consumidor();
        }
    }
}